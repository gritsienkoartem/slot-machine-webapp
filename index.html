<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>3D Змейка с плавным движением</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: sans-serif;
    user-select: none;
  }
  #info {
    position: absolute;
    top: 10px; left: 10px;
    color: white;
    z-index: 10;
    font-size: 18px;
  }
  #scoreboard {
    margin-top: 5px;
  }
  #menu {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #111;
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 20px 30px;
    text-align: center;
    color: #0f0;
    z-index: 20;
    user-select: none;
  }
  #menu h2 {
    margin: 0 0 15px;
  }
  #menu label {
    font-size: 18px;
  }
  #menu select {
    font-size: 16px;
    margin-left: 10px;
    padding: 3px;
    background: #222;
    color: #0f0;
    border: 1px solid #0f0;
    border-radius: 4px;
  }
  #menu button {
    margin-top: 15px;
    font-size: 18px;
    padding: 10px 20px;
    background: #008800;
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
  #controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    display: flex;
    gap: 10px;
  }
  .btn {
    background: #333;
    color: white;
    border: none;
    font-size: 24px;
    padding: 12px 18px;
    border-radius: 8px;
    user-select: none;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  .btn:active {
    opacity: 1;
  }
</style>
</head>
<body>

<div id="info">
  Счёт: <span id="score">0</span><br/>
  Рекорд: <span id="highscore">0</span>
</div>

<div id="menu">
  <h2>Выбери скорость змейки</h2>
  <label for="speedSelect">Скорость:</label>
  <select id="speedSelect">
    <option value="400">Медленно</option>
    <option value="300" selected>Средне</option>
    <option value="150">Быстро</option>
    <option value="80">Очень быстро</option>
  </select>
  <br/>
  <button id="startBtn">Старт</button>
</div>

<div id="controls" style="display:none;">
  <button class="btn" data-dir="up">↑</button>
  <button class="btn" data-dir="left">←</button>
  <button class="btn" data-dir="down">↓</button>
  <button class="btn" data-dir="right">→</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
  let scene, camera, renderer;
  let segments = [];
  let direction = {x: 1, y: 0};
  let apple = null;
  let score = 0;
  let scoreEl, highscoreEl;
  let moveInterval = 300;
  let fieldLimit = 19;
  let gameRunning = false;

  // Для плавного движения
  let segmentPositions = [];
  let targetPositions = [];
  let moveProgress = 0;
  let moveSpeed = 0.005;

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 18, 25);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Пол
    const planeGeo = new THREE.PlaneGeometry(40, 40);
    const planeMat = new THREE.MeshStandardMaterial({color: 0x222222});
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI/2;
    scene.add(plane);

    // Границы
    createWall(0.5, 40, -20, 0);
    createWall(0.5, 40, 20, 0);
    createWall(40, 0.5, 0, -20);
    createWall(40, 0.5, 0, 20);

    scoreEl = document.getElementById('score');
    highscoreEl = document.getElementById('highscore');

    const storedHigh = localStorage.getItem('snakeHighscore');
    if (storedHigh) highscoreEl.textContent = storedHigh;

    window.addEventListener('keydown', e => {
      if (!gameRunning) return;
      if (e.key === 'ArrowUp') setDirection('up');
      else if (e.key === 'ArrowDown') setDirection('down');
      else if (e.key === 'ArrowLeft') setDirection('left');
      else if (e.key === 'ArrowRight') setDirection('right');
    });

    document.querySelectorAll('#controls .btn').forEach(button => {
      button.addEventListener('click', () => {
        if (!gameRunning) return;
        setDirection(button.getAttribute('data-dir'));
      });
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  function createWall(width, depth, x, z) {
    const geo = new THREE.BoxGeometry(width, 2, depth);
    const mat = new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x0088ff, emissiveIntensity: 0.3 });
    const wall = new THREE.Mesh(geo, mat);
    wall.position.set(x, 1, z);
    scene.add(wall);
  }

  function createSegment(x, y, isHead = false) {
    const geo = new THREE.CylinderGeometry(0.45, 0.45, 1, 20);
    const color = isHead ? 0x00ff00 : 0x006600;
    const mat = new THREE.MeshStandardMaterial({
      color: color,
      emissive: isHead ? 0x00ff00 : 0x003300,
      emissiveIntensity: isHead ? 0.8 : 0.3,
      roughness: 0.5,
      metalness: 0.3,
    });
    const segment = new THREE.Mesh(geo, mat);
    segment.rotation.x = Math.PI/2;
    segment.position.set(x, 0.5, y);
    scene.add(segment);
    return segment;
  }

  function createAppleMesh() {
    const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff2222, roughness: 0.4, metalness: 0.6 });
    const appleSphere = new THREE.Mesh(sphereGeo, sphereMat);

    const coneGeo = new THREE.ConeGeometry(0.1, 0.3, 6);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.8, metalness: 0.2 });

    const appleGroup = new THREE.Group();
    appleGroup.add(appleSphere);

    const spikeCount = 12;
    for (let i = 0; i < spikeCount; i++) {
      const cone = new THREE.Mesh(coneGeo, coneMat);
      const angle = (i / spikeCount) * Math.PI * 2;
      cone.position.set(0.4 * Math.cos(angle), 0.3, 0.4 * Math.sin(angle));
      cone.rotation.x = Math.PI;
      appleGroup.add(cone);
    }
    return appleGroup;
  }

  function spawnApple() {
    if (apple) scene.remove(apple);
    let valid = false;
    let x, y;
    while (!valid) {
      x = Math.floor(Math.random() * (fieldLimit * 2 + 1)) - fieldLimit;
      y = Math.floor(Math.random() * (fieldLimit * 2 + 1)) - fieldLimit;
      if (!targetPositions.some(s => s.x === x && s.y === y)) valid = true;
    }
    apple = createAppleMesh();
    apple.position.set(x, 0.5, y);
    scene.add(apple);
  }

  function setDirection(dir) {
    if (dir === 'up' && direction.y !== -1) {
      direction = {x:0, y:1};
    } else if (dir === 'down' && direction.y !== 1) {
      direction = {x:0, y:-1};
    } else if (dir === 'left' && direction.x !== 1) {
      direction = {x:-1, y:0};
    } else if (dir === 'right' && direction.x !== -1) {
      direction = {x:1, y:0};
    }
  }

  function gameOver(reason) {
    alert('Игра окончена: ' + reason + '\nСчёт: ' + score);
    gameRunning = false;
    document.getElementById('menu').style.display = 'block';
    document.getElementById('controls').style.display = 'none';
    if (score > +highscoreEl.textContent) {
      highscoreEl.textContent = score;
      localStorage.setItem('snakeHighscore', score);
    }
  }

  function startGame() {
    segments.forEach(s => scene.remove(s));
    segments = [];
    if (apple) {
      scene.remove(apple);
      apple = null;
    }

    score = 0;
    scoreEl.textContent = score;
    direction = {x:1, y:0};
    targetPositions = [{x: 0, y: 0}];
    segmentPositions = [{x: 0, y: 0}];
    moveProgress = 0;

    segments.push(createSegment(0, 0, true));

    spawnApple();

    const speedVal = +document.getElementById('speedSelect').value;
    moveInterval = speedVal;
    moveSpeed = 0.005 + (300 - speedVal) / 100000;

    gameRunning = true;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('controls').style.display = 'flex';
  }

  let lastTime = 0;
  function animate(time = 0) {
    requestAnimationFrame(animate);
    if (!gameRunning) {
      renderer.render(scene, camera);
      return;
    }

    const delta = time - lastTime;
    lastTime = time;

    moveProgress += moveSpeed * delta;

    if (moveProgress >= 1) {
      moveProgress = 0;

      const newHead = {
        x: targetPositions[0].x + direction.x,
        y: targetPositions[0].y + direction.y,
      };

      // Выход за границы
      if (newHead.x < -fieldLimit || newHead.x > fieldLimit || newHead.y < -fieldLimit || newHead.y > fieldLimit) {
        gameOver('Вышел за границы!');
        return;
      }

      // Столкновение с телом
      if (targetPositions.some(pos => pos.x === newHead.x && pos.y === newHead.y)) {
        gameOver('Столкновение с телом!');
        return;
      }

      targetPositions.unshift(newHead);

      // Яблоко
      if (apple && newHead.x === Math.round(apple.position.x) && newHead.y === Math.round(apple.position.z)) {
        score++;
        scoreEl.textContent = score;
        spawnApple();
      } else {
        targetPositions.pop();
      }

      // Обновляем сегменты, если надо добавлять новый
      while (segments.length < targetPositions.length) {
        segments.push(createSegment(targetPositions[segments.length].x, targetPositions[segments.length].y));
      }
    }

    // Плавное обновление позиции сегментов
    for (let i = 0; i < segments.length; i++) {
      let current = targetPositions[i];
      let next = targetPositions[i+1] || current;
      segments[i].position.x = THREE.MathUtils.lerp(next.x, current.x, moveProgress);
      segments[i].position.z = THREE.MathUtils.lerp(next.y, current.y, moveProgress);
    }

    // Плавный поворот головы по направлению движения
    if (segments.length > 0) {
      const head = segments[0];
      const angle = Math.atan2(direction.y, direction.x);
      head.rotation.y = -angle + Math.PI/2;
    }

    renderer.render(scene, camera);
  }

  document.getElementById('startBtn').addEventListener('click', startGame);

  init();
  animate();
</script>
</body>
</html>
