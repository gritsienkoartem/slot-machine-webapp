<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>3D –ó–º–µ–π–∫–∞ –Ω–∞ Three.js üêç</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: sans-serif;
    user-select: none;
  }
  #info {
    position: absolute;
    top: 10px; left: 10px;
    color: white;
    z-index: 10;
  }
  #controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    display: flex;
    gap: 10px;
  }
  .btn {
    background: #333;
    color: white;
    border: none;
    font-size: 24px;
    padding: 12px 18px;
    border-radius: 8px;
    user-select: none;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  .btn:active {
    opacity: 1;
  }
</style>
</head>
<body>
  <div id="info">–°—á—ë—Ç: <span id="score">0</span></div>
  <div id="controls">
    <button class="btn" data-dir="up">‚Üë</button>
    <button class="btn" data-dir="left">‚Üê</button>
    <button class="btn" data-dir="down">‚Üì</button>
    <button class="btn" data-dir="right">‚Üí</button>
  </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
  // –°—Ü–µ–Ω–∞, –∫–∞–º–µ—Ä–∞, —Ä–µ–Ω–¥–µ—Ä–µ—Ä
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 18, 25);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // –°–≤–µ—Ç
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  scene.add(directionalLight);

  // –ü–æ–ª
  const planeGeo = new THREE.PlaneGeometry(40, 40);
  const planeMat = new THREE.MeshStandardMaterial({color: 0x222222});
  const plane = new THREE.Mesh(planeGeo, planeMat);
  plane.rotation.x = -Math.PI/2;
  scene.add(plane);

  // –ì—Ä–∞–Ω–∏—Ü—ã –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è (—Å—Ç–µ–Ω–∫–∏)
  const wallHeight = 2;
  const wallThickness = 0.5;
  const wallColor = 0x0088ff;
  const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, emissive: wallColor, emissiveIntensity: 0.3 });

  // –°–æ–∑–¥–∞—ë–º 4 —Å—Ç–µ–Ω—ã
  const walls = [];
  const createWall = (width, depth, x, z) => {
    const geo = new THREE.BoxGeometry(width, wallHeight, depth);
    const wall = new THREE.Mesh(geo, wallMat);
    wall.position.set(x, wallHeight/2, z);
    scene.add(wall);
    walls.push(wall);
  }
  // –õ–µ–≤–∞—è –∏ –ø—Ä–∞–≤–∞—è —Å—Ç–µ–Ω—ã (—É–∑–∫–∏–µ)
  createWall(wallThickness, 40, -20, 0);
  createWall(wallThickness, 40, 20, 0);
  // –ü–µ—Ä–µ–¥–Ω—è—è –∏ –∑–∞–¥–Ω—è—è —Å—Ç–µ–Ω—ã (—à–∏—Ä–æ–∫–∏–µ)
  createWall(40, wallThickness, 0, -20);
  createWall(40, wallThickness, 0, 20);

  // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã
  const gridSize = 1;
  const fieldLimit = 19; // –≥—Ä–∞–Ω–∏—Ü–∞ –ø–æ–ª—è -19..19 –ø–æ –æ—Å—è–º x,z

  // –ó–º–µ–π–∫–∞
  let snake = [{x: 0, y: 0}];
  let direction = {x: 1, y: 0};
  let segments = [];

  // –Ø–±–ª–æ–∫–æ
  let apple = null;

  // –°—á—ë—Ç
  let score = 0;
  const scoreEl = document.getElementById('score');
  scoreEl.textContent = score;

  // –°–æ–∑–¥–∞—ë–º —Å–µ–≥–º–µ–Ω—Ç –∑–º–µ–π–∫–∏
  function createSegment(x, y, isHead = false) {
    const geo = new THREE.CylinderGeometry(0.45, 0.45, 1, 20);
    // –ì—Ä–∞–¥–∏–µ–Ω—Ç —Ü–≤–µ—Ç–∞: –≥–æ–ª–æ–≤–∞ —è—Ä—á–µ
    const color = isHead ? 0x00ff00 : 0x006600;
    const mat = new THREE.MeshStandardMaterial({
      color: color,
      emissive: isHead ? 0x00ff00 : 0x003300,
      emissiveIntensity: isHead ? 0.8 : 0.3,
      roughness: 0.5,
      metalness: 0.3,
    });
    const segment = new THREE.Mesh(geo, mat);
    segment.rotation.x = Math.PI/2;
    segment.position.set(x, 0.5, y);
    scene.add(segment);
    return segment;
  }

  // –°–æ–∑–¥–∞—ë–º —è–±–ª–æ–∫–æ —Å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π (—à–∞—Ä —Å —à–∏–ø–∞–º–∏)
  function createAppleMesh() {
    const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff2222, roughness: 0.4, metalness: 0.6 });
    const appleSphere = new THREE.Mesh(sphereGeo, sphereMat);

    // –°–æ–∑–¥–∞–¥–∏–º —à–∏–ø—ã (–º–∞–ª–µ–Ω—å–∫–∏–µ –∫–æ–Ω—É—Å—ã)
    const coneGeo = new THREE.ConeGeometry(0.1, 0.3, 6);
    const coneMat = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.8, metalness: 0.2 });

    const appleGroup = new THREE.Group();
    appleGroup.add(appleSphere);

    // –†–∞—Å—Å—Ç–∞–≤–∏–º —à–∏–ø—ã –ø–æ —Å—Ñ–µ—Ä–∞–º
    const spikeCount = 12;
    for (let i = 0; i < spikeCount; i++) {
      const cone = new THREE.Mesh(coneGeo, coneMat);
      const angle = (i / spikeCount) * Math.PI * 2;
      cone.position.set(0.4 * Math.cos(angle), 0.3, 0.4 * Math.sin(angle));
      cone.rotation.x = Math.PI;
      appleGroup.add(cone);
    }
    return appleGroup;
  }

  // –°–ø–∞–≤–Ω —è–±–ª–æ–∫–∞ –≤ —Ä–∞–Ω–¥–æ–º–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
  function spawnApple() {
    if (apple) scene.remove(apple);
    const x = Math.floor(Math.random() * (fieldLimit * 2 + 1)) - fieldLimit;
    const y = Math.floor(Math.random() * (fieldLimit * 2 + 1)) - fieldLimit;
    apple = createAppleMesh();
    apple.position.set(x, 0.5, y);
    scene.add(apple);
  }

  // –û–±–Ω–æ–≤–ª—è–µ–º –∑–º–µ–π–∫—É (–¥–≤–∏–∂–µ–Ω–∏–µ, —Å—ä–µ–¥–∞–Ω–∏–µ, —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è)
  function updateSnake() {
    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è
    if (head.x < -fieldLimit || head.x > fieldLimit || head.y < -fieldLimit || head.y > fieldLimit) {
      alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –¢—ã –≤—ã—à–µ–ª –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã. –°—á—ë—Ç: ${score}`);
      location.reload();
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å —Ç–µ–ª–æ–º
    if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –¢—ã —Å—Ç–æ–ª–∫–Ω—É–ª—Å—è —Å —Å–æ–±–æ–π. –°—á—ë—Ç: ${score}`);
      location.reload();
    }

    snake.unshift(head);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—ä–µ–¥–∞–Ω–∏—è —è–±–ª–æ–∫–∞
    if (apple && head.x === Math.round(apple.position.x) && head.y === Math.round(apple.position.z)) {
      score++;
      scoreEl.textContent = score;
      spawnApple();
    } else {
      snake.pop();
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–µ–≥–º–µ–Ω—Ç—ã –∑–º–µ–π–∫–∏ –Ω–∞ —Å—Ü–µ–Ω–µ
    segments.forEach(s => scene.remove(s));
    segments = snake.map((pos, i) => createSegment(pos.x, pos.y, i === 0));
  }

  // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
  function setDirection(dir) {
    // –ó–∞–ø—Ä–µ—â–∞–µ–º —Ä–∞–∑–≤–æ—Ä–æ—Ç –∑–º–µ–π–∫–∏ –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤
    if (dir === 'up' && direction.y !== -1) direction = {x: 0, y: 1};
    else if (dir === 'down' && direction.y !== 1) direction = {x: 0, y: -1};
    else if (dir === 'left' && direction.x !== 1) direction = {x: -1, y: 0};
    else if (dir === 'right' && direction.x !== -1) direction = {x: 1, y: 0};
  }

  // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp') setDirection('up');
    else if (e.key === 'ArrowDown') setDirection('down');
    else if (e.key === 'ArrowLeft') setDirection('left');
    else if (e.key === 'ArrowRight') setDirection('right');
  });

  // –ö–Ω–æ–ø–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ
  document.querySelectorAll('#controls
